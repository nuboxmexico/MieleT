{"ast":null,"code":"/*!\nFullCalendar v5.5.0\nDocs & License: https://fullcalendar.io/\n(c) 2020 Adam Shaw\n*/\nimport './main.css';\nimport { createRef, getStickyHeaderDates, createElement, ViewRoot, SimpleScrollGrid, getStickyFooterScrollbar, DateComponent, renderScrollShim, buildNavLinkData, DayCellContent, Fragment, BaseComponent, createFormatter, setRef, DayCellRoot, WeekNumberRoot, RenderHook, buildSegTimeText, EventRoot, StandardEvent, sortEventSegs, addDays, intersectRanges, RefMap, isPropsEqual, getSegMeta, buildEventRangeKey, BgEvent, renderFill, PositionCache, mapHash, DelayedRunner, applyStyle, memoize, NowTimer, EventApi, Slicer, DayHeader, DaySeriesModel, DayTableModel, addWeeks, diffWeeks, DateProfileGenerator, identity, createPlugin } from '@fullcalendar/common';\nimport { __extends, __assign, __spreadArrays } from 'tslib';\n/* An abstract class for the daygrid views, as well as month view. Renders one or more rows of day cells.\n----------------------------------------------------------------------------------------------------------------------*/\n// It is a manager for a Table subcomponent, which does most of the heavy lifting.\n// It is responsible for managing width/height.\n\nvar TableView =\n/** @class */\nfunction (_super) {\n  __extends(TableView, _super);\n\n  function TableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.headerElRef = createRef();\n    return _this;\n  }\n\n  TableView.prototype.renderSimpleLayout = function (headerRowContent, bodyContent) {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var sections = [];\n    var stickyHeaderDates = getStickyHeaderDates(context.options);\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunk: {\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunk: {\n        content: bodyContent\n      }\n    });\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, createElement(SimpleScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        cols: []\n        /* TODO: make optional? */\n        ,\n        sections: sections\n      }));\n    });\n  };\n\n  TableView.prototype.renderHScrollLayout = function (headerRowContent, bodyContent, colCnt, dayMinWidth) {\n    var ScrollGrid = this.context.pluginHooks.scrollGridImpl;\n\n    if (!ScrollGrid) {\n      throw new Error('No ScrollGrid implementation');\n    }\n\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var stickyHeaderDates = !props.forPrint && getStickyHeaderDates(context.options);\n    var stickyFooterScrollbar = !props.forPrint && getStickyFooterScrollbar(context.options);\n    var sections = [];\n\n    if (headerRowContent) {\n      sections.push({\n        type: 'header',\n        key: 'header',\n        isSticky: stickyHeaderDates,\n        chunks: [{\n          key: 'main',\n          elRef: this.headerElRef,\n          tableClassName: 'fc-col-header',\n          rowContent: headerRowContent\n        }]\n      });\n    }\n\n    sections.push({\n      type: 'body',\n      key: 'body',\n      liquid: true,\n      chunks: [{\n        key: 'main',\n        content: bodyContent\n      }]\n    });\n\n    if (stickyFooterScrollbar) {\n      sections.push({\n        type: 'footer',\n        key: 'footer',\n        isSticky: true,\n        chunks: [{\n          key: 'main',\n          content: renderScrollShim\n        }]\n      });\n    }\n\n    return createElement(ViewRoot, {\n      viewSpec: context.viewSpec\n    }, function (rootElRef, classNames) {\n      return createElement(\"div\", {\n        ref: rootElRef,\n        className: ['fc-daygrid'].concat(classNames).join(' ')\n      }, createElement(ScrollGrid, {\n        liquid: !props.isHeightAuto && !props.forPrint,\n        colGroups: [{\n          cols: [{\n            span: colCnt,\n            minWidth: dayMinWidth\n          }]\n        }],\n        sections: sections\n      }));\n    });\n  };\n\n  return TableView;\n}(DateComponent);\n\nfunction splitSegsByRow(segs, rowCnt) {\n  var byRow = [];\n\n  for (var i = 0; i < rowCnt; i += 1) {\n    byRow[i] = [];\n  }\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    byRow[seg.row].push(seg);\n  }\n\n  return byRow;\n}\n\nfunction splitSegsByFirstCol(segs, colCnt) {\n  var byCol = [];\n\n  for (var i = 0; i < colCnt; i += 1) {\n    byCol[i] = [];\n  }\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    byCol[seg.firstCol].push(seg);\n  }\n\n  return byCol;\n}\n\nfunction splitInteractionByRow(ui, rowCnt) {\n  var byRow = [];\n\n  if (!ui) {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = null;\n    }\n  } else {\n    for (var i = 0; i < rowCnt; i += 1) {\n      byRow[i] = {\n        affectedInstances: ui.affectedInstances,\n        isEvent: ui.isEvent,\n        segs: []\n      };\n    }\n\n    for (var _i = 0, _a = ui.segs; _i < _a.length; _i++) {\n      var seg = _a[_i];\n      byRow[seg.row].segs.push(seg);\n    }\n  }\n\n  return byRow;\n}\n\nvar TableCellTop =\n/** @class */\nfunction (_super) {\n  __extends(TableCellTop, _super);\n\n  function TableCellTop() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableCellTop.prototype.render = function () {\n    var props = this.props;\n    var navLinkAttrs = this.context.options.navLinks ? {\n      'data-navlink': buildNavLinkData(props.date),\n      tabIndex: 0\n    } : {};\n    return createElement(DayCellContent, {\n      date: props.date,\n      dateProfile: props.dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      defaultContent: renderTopInner\n    }, function (innerElRef, innerContent) {\n      return (innerContent || props.forceDayTop) && createElement(\"div\", {\n        className: \"fc-daygrid-day-top\",\n        ref: innerElRef\n      }, createElement(\"a\", __assign({\n        className: \"fc-daygrid-day-number\"\n      }, navLinkAttrs), innerContent || createElement(Fragment, null, \"\\xA0\")));\n    });\n  };\n\n  return TableCellTop;\n}(BaseComponent);\n\nfunction renderTopInner(props) {\n  return props.dayNumberText;\n}\n\nvar DEFAULT_WEEK_NUM_FORMAT = createFormatter({\n  week: 'narrow'\n});\n\nvar TableCell =\n/** @class */\nfunction (_super) {\n  __extends(TableCell, _super);\n\n  function TableCell() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n      setRef(_this.props.elRef, el);\n    };\n\n    _this.handleMoreLinkClick = function (ev) {\n      var props = _this.props;\n\n      if (props.onMoreClick) {\n        var allSegs = props.segsByEachCol;\n        var hiddenSegs = allSegs.filter(function (seg) {\n          return props.segIsHidden[seg.eventRange.instance.instanceId];\n        });\n        props.onMoreClick({\n          date: props.date,\n          allSegs: allSegs,\n          hiddenSegs: hiddenSegs,\n          moreCnt: props.moreCnt,\n          dayEl: _this.rootEl,\n          ev: ev\n        });\n      }\n    };\n\n    return _this;\n  }\n\n  TableCell.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        viewApi = _a.viewApi;\n    var props = this.props;\n    var date = props.date,\n        dateProfile = props.dateProfile;\n    var hookProps = {\n      num: props.moreCnt,\n      text: props.buildMoreLinkText(props.moreCnt),\n      view: viewApi\n    };\n    var navLinkAttrs = options.navLinks ? {\n      'data-navlink': buildNavLinkData(date, 'week'),\n      tabIndex: 0\n    } : {};\n    return createElement(DayCellRoot, {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: props.todayRange,\n      showDayNumber: props.showDayNumber,\n      extraHookProps: props.extraHookProps,\n      elRef: this.handleRootEl\n    }, function (dayElRef, dayClassNames, rootDataAttrs, isDisabled) {\n      return createElement(\"td\", __assign({\n        ref: dayElRef,\n        className: ['fc-daygrid-day'].concat(dayClassNames, props.extraClassNames || []).join(' ')\n      }, rootDataAttrs, props.extraDataAttrs), createElement(\"div\", {\n        className: \"fc-daygrid-day-frame fc-scrollgrid-sync-inner\",\n        ref: props.innerElRef\n        /* different from hook system! RENAME */\n\n      }, props.showWeekNumber && createElement(WeekNumberRoot, {\n        date: date,\n        defaultFormat: DEFAULT_WEEK_NUM_FORMAT\n      }, function (weekElRef, weekClassNames, innerElRef, innerContent) {\n        return createElement(\"a\", __assign({\n          ref: weekElRef,\n          className: ['fc-daygrid-week-number'].concat(weekClassNames).join(' ')\n        }, navLinkAttrs), innerContent);\n      }), !isDisabled && createElement(TableCellTop, {\n        date: date,\n        dateProfile: dateProfile,\n        showDayNumber: props.showDayNumber,\n        forceDayTop: props.forceDayTop,\n        todayRange: props.todayRange,\n        extraHookProps: props.extraHookProps\n      }), createElement(\"div\", {\n        className: \"fc-daygrid-day-events\",\n        ref: props.fgContentElRef,\n        style: {\n          paddingBottom: props.fgPaddingBottom\n        }\n      }, props.fgContent, Boolean(props.moreCnt) && createElement(\"div\", {\n        className: \"fc-daygrid-day-bottom\",\n        style: {\n          marginTop: props.moreMarginTop\n        }\n      }, createElement(RenderHook, {\n        hookProps: hookProps,\n        classNames: options.moreLinkClassNames,\n        content: options.moreLinkContent,\n        defaultContent: renderMoreLinkInner,\n        didMount: options.moreLinkDidMount,\n        willUnmount: options.moreLinkWillUnmount\n      }, function (rootElRef, classNames, innerElRef, innerContent) {\n        return createElement(\"a\", {\n          ref: rootElRef,\n          className: ['fc-daygrid-more-link'].concat(classNames).join(' '),\n          onClick: _this.handleMoreLinkClick\n        }, innerContent);\n      }))), createElement(\"div\", {\n        className: \"fc-daygrid-day-bg\"\n      }, props.bgContent)));\n    });\n  };\n\n  return TableCell;\n}(DateComponent);\n\nTableCell.addPropsEquality({\n  onMoreClick: true\n});\n\nfunction renderMoreLinkInner(props) {\n  return props.text;\n}\n\nvar DEFAULT_TABLE_EVENT_TIME_FORMAT = createFormatter({\n  hour: 'numeric',\n  minute: '2-digit',\n  omitZeroMinute: true,\n  meridiem: 'narrow'\n});\n\nfunction hasListItemDisplay(seg) {\n  var display = seg.eventRange.ui.display;\n  return display === 'list-item' || display === 'auto' && !seg.eventRange.def.allDay && seg.firstCol === seg.lastCol && // can't be multi-day\n  seg.isStart && // \"\n  seg.isEnd // \"\n  ;\n}\n\nvar TableListItemEvent =\n/** @class */\nfunction (_super) {\n  __extends(TableListItemEvent, _super);\n\n  function TableListItemEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableListItemEvent.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    var timeFormat = context.options.eventTimeFormat || DEFAULT_TABLE_EVENT_TIME_FORMAT;\n    var timeText = buildSegTimeText(props.seg, timeFormat, context, true, props.defaultDisplayEventEnd);\n    return createElement(EventRoot, {\n      seg: props.seg,\n      timeText: timeText,\n      defaultContent: renderInnerContent,\n      isDragging: props.isDragging,\n      isResizing: false,\n      isDateSelecting: false,\n      isSelected: props.isSelected,\n      isPast: props.isPast,\n      isFuture: props.isFuture,\n      isToday: props.isToday\n    }, function (rootElRef, classNames, innerElRef, innerContent) {\n      return (// we don't use styles!\n        createElement(\"a\", __assign({\n          className: ['fc-daygrid-event', 'fc-daygrid-dot-event'].concat(classNames).join(' '),\n          ref: rootElRef\n        }, getSegAnchorAttrs(props.seg)), innerContent)\n      );\n    });\n  };\n\n  return TableListItemEvent;\n}(BaseComponent);\n\nfunction renderInnerContent(innerProps) {\n  return createElement(Fragment, null, createElement(\"div\", {\n    className: \"fc-daygrid-event-dot\",\n    style: {\n      borderColor: innerProps.borderColor || innerProps.backgroundColor\n    }\n  }), innerProps.timeText && createElement(\"div\", {\n    className: \"fc-event-time\"\n  }, innerProps.timeText), createElement(\"div\", {\n    className: \"fc-event-title\"\n  }, innerProps.event.title || createElement(Fragment, null, \"\\xA0\")));\n}\n\nfunction getSegAnchorAttrs(seg) {\n  var url = seg.eventRange.def.url;\n  return url ? {\n    href: url\n  } : {};\n}\n\nvar TableBlockEvent =\n/** @class */\nfunction (_super) {\n  __extends(TableBlockEvent, _super);\n\n  function TableBlockEvent() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  TableBlockEvent.prototype.render = function () {\n    var props = this.props;\n    return createElement(StandardEvent, __assign({}, props, {\n      extraClassNames: ['fc-daygrid-event', 'fc-daygrid-block-event', 'fc-h-event'],\n      defaultTimeFormat: DEFAULT_TABLE_EVENT_TIME_FORMAT,\n      defaultDisplayEventEnd: props.defaultDisplayEventEnd,\n      disableResizing: !props.seg.eventRange.def.allDay\n    }));\n  };\n\n  return TableBlockEvent;\n}(BaseComponent);\n\nfunction computeFgSegPlacement( // for one row. TODO: print mode?\ncellModels, segs, dayMaxEvents, dayMaxEventRows, eventHeights, maxContentHeight, colCnt, eventOrderSpecs) {\n  var colPlacements = []; // if event spans multiple cols, its present in each col\n\n  var moreCnts = []; // by-col\n\n  var segIsHidden = {};\n  var segTops = {}; // always populated for each seg\n\n  var segMarginTops = {}; // simetimes populated for each seg\n\n  var moreTops = {};\n  var paddingBottoms = {}; // for each cell's inner-wrapper div\n\n  for (var i = 0; i < colCnt; i += 1) {\n    colPlacements.push([]);\n    moreCnts.push(0);\n  }\n\n  segs = sortEventSegs(segs, eventOrderSpecs);\n\n  for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n    var seg = segs_1[_i];\n    var instanceId = seg.eventRange.instance.instanceId;\n    var eventHeight = eventHeights[instanceId + ':' + seg.firstCol];\n    placeSeg(seg, eventHeight || 0); // will keep colPlacements sorted by top\n  }\n\n  if (dayMaxEvents === true || dayMaxEventRows === true) {\n    limitByMaxHeight(moreCnts, segIsHidden, colPlacements, maxContentHeight); // populates moreCnts/segIsHidden\n  } else if (typeof dayMaxEvents === 'number') {\n    limitByMaxEvents(moreCnts, segIsHidden, colPlacements, dayMaxEvents); // populates moreCnts/segIsHidden\n  } else if (typeof dayMaxEventRows === 'number') {\n    limitByMaxRows(moreCnts, segIsHidden, colPlacements, dayMaxEventRows); // populates moreCnts/segIsHidden\n  } // computes segTops/segMarginTops/moreTops/paddingBottoms\n\n\n  for (var col = 0; col < colCnt; col += 1) {\n    var placements = colPlacements[col];\n    var currentNonAbsBottom = 0;\n    var currentAbsHeight = 0;\n\n    for (var _a = 0, placements_1 = placements; _a < placements_1.length; _a++) {\n      var placement = placements_1[_a];\n      var seg = placement.seg;\n\n      if (!segIsHidden[seg.eventRange.instance.instanceId]) {\n        segTops[seg.eventRange.instance.instanceId] = placement.top; // from top of container\n\n        if (seg.firstCol === seg.lastCol && seg.isStart && seg.isEnd) {\n          // TODO: simpler way? NOT DRY\n          segMarginTops[seg.eventRange.instance.instanceId] = placement.top - currentNonAbsBottom; // from previous seg bottom\n\n          currentAbsHeight = 0;\n          currentNonAbsBottom = placement.bottom;\n        } else {\n          // multi-col event, abs positioned\n          currentAbsHeight = placement.bottom - currentNonAbsBottom;\n        }\n      }\n    }\n\n    if (currentAbsHeight) {\n      if (moreCnts[col]) {\n        moreTops[col] = currentAbsHeight;\n      } else {\n        paddingBottoms[col] = currentAbsHeight;\n      }\n    }\n  }\n\n  function placeSeg(seg, segHeight) {\n    if (!tryPlaceSegAt(seg, segHeight, 0)) {\n      for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n        for (var _i = 0, _a = colPlacements[col]; _i < _a.length; _i++) {\n          // will repeat multi-day segs!!!!!!! bad!!!!!!\n          var placement = _a[_i];\n\n          if (tryPlaceSegAt(seg, segHeight, placement.bottom)) {\n            return;\n          }\n        }\n      }\n    }\n  }\n\n  function tryPlaceSegAt(seg, segHeight, top) {\n    if (canPlaceSegAt(seg, segHeight, top)) {\n      for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n        var placements = colPlacements[col];\n        var insertionIndex = 0;\n\n        while (insertionIndex < placements.length && top >= placements[insertionIndex].top) {\n          insertionIndex += 1;\n        }\n\n        placements.splice(insertionIndex, 0, {\n          seg: seg,\n          top: top,\n          bottom: top + segHeight\n        });\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  function canPlaceSegAt(seg, segHeight, top) {\n    for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n      for (var _i = 0, _a = colPlacements[col]; _i < _a.length; _i++) {\n        var placement = _a[_i];\n\n        if (top < placement.bottom && top + segHeight > placement.top) {\n          // collide?\n          return false;\n        }\n      }\n    }\n\n    return true;\n  } // what does this do!?\n\n\n  for (var instanceIdAndFirstCol in eventHeights) {\n    if (!eventHeights[instanceIdAndFirstCol]) {\n      segIsHidden[instanceIdAndFirstCol.split(':')[0]] = true;\n    }\n  }\n\n  var segsByFirstCol = colPlacements.map(extractFirstColSegs); // operates on the sorted cols\n\n  var segsByEachCol = colPlacements.map(function (placements, col) {\n    var segsForCols = extractAllColSegs(placements);\n    segsForCols = resliceDaySegs(segsForCols, cellModels[col].date, col);\n    return segsForCols;\n  });\n  return {\n    segsByFirstCol: segsByFirstCol,\n    segsByEachCol: segsByEachCol,\n    segIsHidden: segIsHidden,\n    segTops: segTops,\n    segMarginTops: segMarginTops,\n    moreCnts: moreCnts,\n    moreTops: moreTops,\n    paddingBottoms: paddingBottoms\n  };\n}\n\nfunction extractFirstColSegs(oneColPlacements, col) {\n  var segs = [];\n\n  for (var _i = 0, oneColPlacements_1 = oneColPlacements; _i < oneColPlacements_1.length; _i++) {\n    var placement = oneColPlacements_1[_i];\n\n    if (placement.seg.firstCol === col) {\n      segs.push(placement.seg);\n    }\n  }\n\n  return segs;\n}\n\nfunction extractAllColSegs(oneColPlacements) {\n  var segs = [];\n\n  for (var _i = 0, oneColPlacements_2 = oneColPlacements; _i < oneColPlacements_2.length; _i++) {\n    var placement = oneColPlacements_2[_i];\n    segs.push(placement.seg);\n  }\n\n  return segs;\n}\n\nfunction limitByMaxHeight(hiddenCnts, segIsHidden, colPlacements, maxContentHeight) {\n  limitEvents(hiddenCnts, segIsHidden, colPlacements, true, function (placement) {\n    return placement.bottom <= maxContentHeight;\n  });\n}\n\nfunction limitByMaxEvents(hiddenCnts, segIsHidden, colPlacements, dayMaxEvents) {\n  limitEvents(hiddenCnts, segIsHidden, colPlacements, false, function (placement, levelIndex) {\n    return levelIndex < dayMaxEvents;\n  });\n}\n\nfunction limitByMaxRows(hiddenCnts, segIsHidden, colPlacements, dayMaxEventRows) {\n  limitEvents(hiddenCnts, segIsHidden, colPlacements, true, function (placement, levelIndex) {\n    return levelIndex < dayMaxEventRows;\n  });\n}\n/*\npopulates the given hiddenCnts/segIsHidden, which are supplied empty.\nTODO: return them instead\n*/\n\n\nfunction limitEvents(hiddenCnts, segIsHidden, colPlacements, _moreLinkConsumesLevel, isPlacementInBounds) {\n  var colCnt = hiddenCnts.length;\n  var segIsVisible = {}; // TODO: instead, use segIsHidden with true/false?\n\n  var visibleColPlacements = []; // will mirror colPlacements\n\n  for (var col = 0; col < colCnt; col += 1) {\n    visibleColPlacements.push([]);\n  }\n\n  for (var col = 0; col < colCnt; col += 1) {\n    var placements = colPlacements[col];\n    var level = 0;\n\n    for (var _i = 0, placements_2 = placements; _i < placements_2.length; _i++) {\n      var placement = placements_2[_i];\n\n      if (isPlacementInBounds(placement, level)) {\n        recordVisible(placement);\n      } else {\n        recordHidden(placement, level, _moreLinkConsumesLevel);\n      } // only considered a level if the seg had height\n\n\n      if (placement.top !== placement.bottom) {\n        level += 1;\n      }\n    }\n  }\n\n  function recordVisible(placement) {\n    var seg = placement.seg;\n    var instanceId = seg.eventRange.instance.instanceId;\n\n    if (!segIsVisible[instanceId]) {\n      segIsVisible[instanceId] = true;\n\n      for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n        var destPlacements = visibleColPlacements[col];\n        var newPosition = 0; // insert while keeping top sorted in each column\n\n        while (newPosition < destPlacements.length && placement.top >= destPlacements[newPosition].top) {\n          newPosition += 1;\n        }\n\n        destPlacements.splice(newPosition, 0, placement);\n      }\n    }\n  }\n\n  function recordHidden(placement, currentLevel, moreLinkConsumesLevel) {\n    var seg = placement.seg;\n    var instanceId = seg.eventRange.instance.instanceId;\n\n    if (!segIsHidden[instanceId]) {\n      segIsHidden[instanceId] = true;\n\n      for (var col = seg.firstCol; col <= seg.lastCol; col += 1) {\n        hiddenCnts[col] += 1;\n        var hiddenCnt = hiddenCnts[col];\n\n        if (moreLinkConsumesLevel && hiddenCnt === 1 && currentLevel > 0) {\n          var doomedLevel = currentLevel - 1;\n\n          while (visibleColPlacements[col].length > doomedLevel) {\n            recordHidden(visibleColPlacements[col].pop(), // removes\n            visibleColPlacements[col].length, // will execute after the pop. will be the index of the removed placement\n            false);\n          }\n        }\n      }\n    }\n  }\n} // Given the events within an array of segment objects, reslice them to be in a single day\n\n\nfunction resliceDaySegs(segs, dayDate, colIndex) {\n  var dayStart = dayDate;\n  var dayEnd = addDays(dayStart, 1);\n  var dayRange = {\n    start: dayStart,\n    end: dayEnd\n  };\n  var newSegs = [];\n\n  for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n    var seg = segs_2[_i];\n    var eventRange = seg.eventRange;\n    var origRange = eventRange.range;\n    var slicedRange = intersectRanges(origRange, dayRange);\n\n    if (slicedRange) {\n      newSegs.push(__assign(__assign({}, seg), {\n        firstCol: colIndex,\n        lastCol: colIndex,\n        eventRange: {\n          def: eventRange.def,\n          ui: __assign(__assign({}, eventRange.ui), {\n            durationEditable: false\n          }),\n          instance: eventRange.instance,\n          range: slicedRange\n        },\n        isStart: seg.isStart && slicedRange.start.valueOf() === origRange.start.valueOf(),\n        isEnd: seg.isEnd && slicedRange.end.valueOf() === origRange.end.valueOf()\n      }));\n    }\n  }\n\n  return newSegs;\n}\n\nvar TableRow =\n/** @class */\nfunction (_super) {\n  __extends(TableRow, _super);\n\n  function TableRow() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cellElRefs = new RefMap(); // the <td>\n\n    _this.frameElRefs = new RefMap(); // the fc-daygrid-day-frame\n\n    _this.fgElRefs = new RefMap(); // the fc-daygrid-day-events\n\n    _this.segHarnessRefs = new RefMap(); // indexed by \"instanceId:firstCol\"\n\n    _this.rootElRef = createRef();\n    _this.state = {\n      framePositions: null,\n      maxContentHeight: null,\n      segHeights: {}\n    };\n    return _this;\n  }\n\n  TableRow.prototype.render = function () {\n    var _this = this;\n\n    var _a = this,\n        props = _a.props,\n        state = _a.state,\n        context = _a.context;\n\n    var colCnt = props.cells.length;\n    var businessHoursByCol = splitSegsByFirstCol(props.businessHourSegs, colCnt);\n    var bgEventSegsByCol = splitSegsByFirstCol(props.bgEventSegs, colCnt);\n    var highlightSegsByCol = splitSegsByFirstCol(this.getHighlightSegs(), colCnt);\n    var mirrorSegsByCol = splitSegsByFirstCol(this.getMirrorSegs(), colCnt);\n\n    var _b = computeFgSegPlacement(props.cells, props.fgEventSegs, props.dayMaxEvents, props.dayMaxEventRows, state.segHeights, state.maxContentHeight, colCnt, context.options.eventOrder),\n        paddingBottoms = _b.paddingBottoms,\n        segsByFirstCol = _b.segsByFirstCol,\n        segsByEachCol = _b.segsByEachCol,\n        segIsHidden = _b.segIsHidden,\n        segTops = _b.segTops,\n        segMarginTops = _b.segMarginTops,\n        moreCnts = _b.moreCnts,\n        moreTops = _b.moreTops;\n\n    var selectedInstanceHash = // TODO: messy way to compute this\n    props.eventDrag && props.eventDrag.affectedInstances || props.eventResize && props.eventResize.affectedInstances || {};\n    return createElement(\"tr\", {\n      ref: this.rootElRef\n    }, props.renderIntro && props.renderIntro(), props.cells.map(function (cell, col) {\n      var normalFgNodes = _this.renderFgSegs(segsByFirstCol[col], segIsHidden, segTops, segMarginTops, selectedInstanceHash, props.todayRange);\n\n      var mirrorFgNodes = _this.renderFgSegs(mirrorSegsByCol[col], {}, segTops, // use same tops as real rendering\n      {}, {}, props.todayRange, Boolean(props.eventDrag), Boolean(props.eventResize), false);\n\n      return createElement(TableCell, {\n        key: cell.key,\n        elRef: _this.cellElRefs.createRef(cell.key),\n        innerElRef: _this.frameElRefs.createRef(cell.key)\n        /* FF <td> problem, but okay to use for left/right. TODO: rename prop */\n        ,\n        dateProfile: props.dateProfile,\n        date: cell.date,\n        showDayNumber: props.showDayNumbers,\n        showWeekNumber: props.showWeekNumbers && col === 0,\n        forceDayTop: props.showWeekNumbers\n        /* even displaying weeknum for row, not necessarily day */\n        ,\n        todayRange: props.todayRange,\n        extraHookProps: cell.extraHookProps,\n        extraDataAttrs: cell.extraDataAttrs,\n        extraClassNames: cell.extraClassNames,\n        moreCnt: moreCnts[col],\n        buildMoreLinkText: props.buildMoreLinkText,\n        onMoreClick: function onMoreClick(arg) {\n          props.onMoreClick(__assign(__assign({}, arg), {\n            fromCol: col\n          }));\n        },\n        segIsHidden: segIsHidden,\n        moreMarginTop: moreTops[col]\n        /* rename */\n        ,\n        segsByEachCol: segsByEachCol[col],\n        fgPaddingBottom: paddingBottoms[col],\n        fgContentElRef: _this.fgElRefs.createRef(cell.key),\n        fgContent: // Fragment scopes the keys\n        createElement(Fragment, null, createElement(Fragment, null, normalFgNodes), createElement(Fragment, null, mirrorFgNodes)),\n        bgContent: // Fragment scopes the keys\n        createElement(Fragment, null, _this.renderFillSegs(highlightSegsByCol[col], 'highlight'), _this.renderFillSegs(businessHoursByCol[col], 'non-business'), _this.renderFillSegs(bgEventSegsByCol[col], 'bg-event'))\n      });\n    }));\n  };\n\n  TableRow.prototype.componentDidMount = function () {\n    this.updateSizing(true);\n  };\n\n  TableRow.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var currentProps = this.props;\n    this.updateSizing(!isPropsEqual(prevProps, currentProps));\n  };\n\n  TableRow.prototype.getHighlightSegs = function () {\n    var props = this.props;\n\n    if (props.eventDrag && props.eventDrag.segs.length) {\n      // messy check\n      return props.eventDrag.segs;\n    }\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return props.dateSelectionSegs;\n  };\n\n  TableRow.prototype.getMirrorSegs = function () {\n    var props = this.props;\n\n    if (props.eventResize && props.eventResize.segs.length) {\n      // messy check\n      return props.eventResize.segs;\n    }\n\n    return [];\n  };\n\n  TableRow.prototype.renderFgSegs = function (segs, segIsHidden, // does NOT mean display:hidden\n  segTops, segMarginTops, selectedInstanceHash, todayRange, isDragging, isResizing, isDateSelecting) {\n    var context = this.context;\n    var eventSelection = this.props.eventSelection;\n    var framePositions = this.state.framePositions;\n    var defaultDisplayEventEnd = this.props.cells.length === 1; // colCnt === 1\n\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_1 = segs; _i < segs_1.length; _i++) {\n        var seg = segs_1[_i];\n        var instanceId = seg.eventRange.instance.instanceId;\n        var isMirror = isDragging || isResizing || isDateSelecting;\n        var isSelected = selectedInstanceHash[instanceId];\n        var isInvisible = segIsHidden[instanceId] || isSelected; // TODO: simpler way? NOT DRY\n\n        var isAbsolute = segIsHidden[instanceId] || isMirror || seg.firstCol !== seg.lastCol || !seg.isStart || !seg.isEnd;\n        var marginTop = void 0;\n        var top_1 = void 0;\n        var left = void 0;\n        var right = void 0;\n\n        if (isAbsolute) {\n          top_1 = segTops[instanceId];\n\n          if (context.isRtl) {\n            right = 0;\n            left = framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol];\n          } else {\n            left = 0;\n            right = framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol];\n          }\n        } else {\n          marginTop = segMarginTops[instanceId];\n        }\n        /*\n        known bug: events that are force to be list-item but span multiple days still take up space in later columns\n        */\n\n\n        nodes.push(createElement(\"div\", {\n          className: 'fc-daygrid-event-harness' + (isAbsolute ? ' fc-daygrid-event-harness-abs' : ''),\n          key: instanceId,\n          // in print mode when in mult cols, could collide\n          ref: isMirror ? null : this.segHarnessRefs.createRef(instanceId + ':' + seg.firstCol),\n          style: {\n            visibility: isInvisible ? 'hidden' : '',\n            marginTop: marginTop || '',\n            top: top_1 || '',\n            left: left || '',\n            right: right || ''\n          }\n        }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, __assign({\n          seg: seg,\n          isDragging: isDragging,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, getSegMeta(seg, todayRange))) : createElement(TableBlockEvent, __assign({\n          seg: seg,\n          isDragging: isDragging,\n          isResizing: isResizing,\n          isDateSelecting: isDateSelecting,\n          isSelected: instanceId === eventSelection,\n          defaultDisplayEventEnd: defaultDisplayEventEnd\n        }, getSegMeta(seg, todayRange)))));\n      }\n    }\n\n    return nodes;\n  };\n\n  TableRow.prototype.renderFillSegs = function (segs, fillType) {\n    var isRtl = this.context.isRtl;\n    var todayRange = this.props.todayRange;\n    var framePositions = this.state.framePositions;\n    var nodes = [];\n\n    if (framePositions) {\n      for (var _i = 0, segs_2 = segs; _i < segs_2.length; _i++) {\n        var seg = segs_2[_i];\n        var leftRightCss = isRtl ? {\n          right: 0,\n          left: framePositions.lefts[seg.lastCol] - framePositions.lefts[seg.firstCol]\n        } : {\n          left: 0,\n          right: framePositions.rights[seg.firstCol] - framePositions.rights[seg.lastCol]\n        };\n        nodes.push(createElement(\"div\", {\n          key: buildEventRangeKey(seg.eventRange),\n          className: \"fc-daygrid-bg-harness\",\n          style: leftRightCss\n        }, fillType === 'bg-event' ? createElement(BgEvent, __assign({\n          seg: seg\n        }, getSegMeta(seg, todayRange))) : renderFill(fillType)));\n      }\n    }\n\n    return createElement.apply(void 0, __spreadArrays([Fragment, {}], nodes));\n  };\n\n  TableRow.prototype.updateSizing = function (isExternalSizingChange) {\n    var _a = this,\n        props = _a.props,\n        frameElRefs = _a.frameElRefs;\n\n    if (props.clientWidth !== null) {\n      // positioning ready?\n      if (isExternalSizingChange) {\n        var frameEls = props.cells.map(function (cell) {\n          return frameElRefs.currentMap[cell.key];\n        });\n\n        if (frameEls.length) {\n          var originEl = this.rootElRef.current;\n          this.setState({\n            framePositions: new PositionCache(originEl, frameEls, true, // isHorizontal\n            false)\n          });\n        }\n      }\n\n      var limitByContentHeight = props.dayMaxEvents === true || props.dayMaxEventRows === true;\n      this.setState({\n        segHeights: this.computeSegHeights(),\n        maxContentHeight: limitByContentHeight ? this.computeMaxContentHeight() : null\n      });\n    }\n  };\n\n  TableRow.prototype.computeSegHeights = function () {\n    return mapHash(this.segHarnessRefs.currentMap, function (eventHarnessEl) {\n      return eventHarnessEl.getBoundingClientRect().height;\n    });\n  };\n\n  TableRow.prototype.computeMaxContentHeight = function () {\n    var firstKey = this.props.cells[0].key;\n    var cellEl = this.cellElRefs.currentMap[firstKey];\n    var fcContainerEl = this.fgElRefs.currentMap[firstKey];\n    return cellEl.getBoundingClientRect().bottom - fcContainerEl.getBoundingClientRect().top;\n  };\n\n  TableRow.prototype.getCellEls = function () {\n    var elMap = this.cellElRefs.currentMap;\n    return this.props.cells.map(function (cell) {\n      return elMap[cell.key];\n    });\n  };\n\n  return TableRow;\n}(DateComponent);\n\nTableRow.addPropsEquality({\n  onMoreClick: true\n});\nTableRow.addStateEquality({\n  segHeights: isPropsEqual\n});\nvar PADDING_FROM_VIEWPORT = 10;\nvar SCROLL_DEBOUNCE = 10;\n\nvar Popover =\n/** @class */\nfunction (_super) {\n  __extends(Popover, _super);\n\n  function Popover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.repositioner = new DelayedRunner(_this.updateSize.bind(_this));\n\n    _this.handleRootEl = function (el) {\n      _this.rootEl = el;\n\n      if (_this.props.elRef) {\n        setRef(_this.props.elRef, el);\n      }\n    }; // Triggered when the user clicks *anywhere* in the document, for the autoHide feature\n\n\n    _this.handleDocumentMousedown = function (ev) {\n      var onClose = _this.props.onClose; // only hide the popover if the click happened outside the popover\n\n      if (onClose && !_this.rootEl.contains(ev.target)) {\n        onClose();\n      }\n    };\n\n    _this.handleDocumentScroll = function () {\n      _this.repositioner.request(SCROLL_DEBOUNCE);\n    };\n\n    _this.handleCloseClick = function () {\n      var onClose = _this.props.onClose;\n\n      if (onClose) {\n        onClose();\n      }\n    };\n\n    return _this;\n  }\n\n  Popover.prototype.render = function () {\n    var theme = this.context.theme;\n    var props = this.props;\n    var classNames = ['fc-popover', theme.getClass('popover')].concat(props.extraClassNames || []);\n    return createElement(\"div\", __assign({\n      className: classNames.join(' ')\n    }, props.extraAttrs, {\n      ref: this.handleRootEl\n    }), createElement(\"div\", {\n      className: 'fc-popover-header ' + theme.getClass('popoverHeader')\n    }, createElement(\"span\", {\n      className: \"fc-popover-title\"\n    }, props.title), createElement(\"span\", {\n      className: 'fc-popover-close ' + theme.getIconClass('close'),\n      onClick: this.handleCloseClick\n    })), createElement(\"div\", {\n      className: 'fc-popover-body ' + theme.getClass('popoverContent')\n    }, props.children));\n  };\n\n  Popover.prototype.componentDidMount = function () {\n    document.addEventListener('mousedown', this.handleDocumentMousedown);\n    document.addEventListener('scroll', this.handleDocumentScroll);\n    this.updateSize();\n  };\n\n  Popover.prototype.componentWillUnmount = function () {\n    document.removeEventListener('mousedown', this.handleDocumentMousedown);\n    document.removeEventListener('scroll', this.handleDocumentScroll);\n  }; // TODO: adjust on window resize\n\n  /*\n  NOTE: the popover is position:fixed, so coordinates are relative to the viewport\n  NOTE: the PARENT calls this as well, on window resize. we would have wanted to use the repositioner,\n        but need to ensure that all other components have updated size first (for alignmentEl)\n  */\n\n\n  Popover.prototype.updateSize = function () {\n    var _a = this.props,\n        alignmentEl = _a.alignmentEl,\n        topAlignmentEl = _a.topAlignmentEl;\n    var rootEl = this.rootEl;\n\n    if (!rootEl) {\n      return; // not sure why this was null, but we shouldn't let external components call updateSize() anyway\n    }\n\n    var dims = rootEl.getBoundingClientRect(); // only used for width,height\n\n    var alignment = alignmentEl.getBoundingClientRect();\n    var top = topAlignmentEl ? topAlignmentEl.getBoundingClientRect().top : alignment.top;\n    top = Math.min(top, window.innerHeight - dims.height - PADDING_FROM_VIEWPORT);\n    top = Math.max(top, PADDING_FROM_VIEWPORT);\n    var left;\n\n    if (this.context.isRtl) {\n      left = alignment.right - dims.width;\n    } else {\n      left = alignment.left;\n    }\n\n    left = Math.min(left, window.innerWidth - dims.width - PADDING_FROM_VIEWPORT);\n    left = Math.max(left, PADDING_FROM_VIEWPORT);\n    applyStyle(rootEl, {\n      top: top,\n      left: left\n    });\n  };\n\n  return Popover;\n}(BaseComponent);\n\nvar MorePopover =\n/** @class */\nfunction (_super) {\n  __extends(MorePopover, _super);\n\n  function MorePopover() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.rootElRef = createRef();\n    return _this;\n  }\n\n  MorePopover.prototype.render = function () {\n    var _a = this.context,\n        options = _a.options,\n        dateEnv = _a.dateEnv;\n    var props = this.props;\n    var date = props.date,\n        hiddenInstances = props.hiddenInstances,\n        todayRange = props.todayRange,\n        dateProfile = props.dateProfile,\n        selectedInstanceId = props.selectedInstanceId;\n    var title = dateEnv.format(date, options.dayPopoverFormat);\n    return createElement(DayCellRoot, {\n      date: date,\n      dateProfile: dateProfile,\n      todayRange: todayRange,\n      elRef: this.rootElRef\n    }, function (rootElRef, dayClassNames, dataAttrs) {\n      return createElement(Popover, {\n        elRef: rootElRef,\n        title: title,\n        extraClassNames: ['fc-more-popover'].concat(dayClassNames),\n        extraAttrs: dataAttrs,\n        onClose: props.onCloseClick,\n        alignmentEl: props.alignmentEl,\n        topAlignmentEl: props.topAlignmentEl\n      }, createElement(DayCellContent, {\n        date: date,\n        dateProfile: dateProfile,\n        todayRange: todayRange\n      }, function (innerElRef, innerContent) {\n        return innerContent && createElement(\"div\", {\n          className: \"fc-more-popover-misc\",\n          ref: innerElRef\n        }, innerContent);\n      }), props.segs.map(function (seg) {\n        var instanceId = seg.eventRange.instance.instanceId;\n        return createElement(\"div\", {\n          className: \"fc-daygrid-event-harness\",\n          key: instanceId,\n          style: {\n            visibility: hiddenInstances[instanceId] ? 'hidden' : ''\n          }\n        }, hasListItemDisplay(seg) ? createElement(TableListItemEvent, __assign({\n          seg: seg,\n          isDragging: false,\n          isSelected: instanceId === selectedInstanceId,\n          defaultDisplayEventEnd: false\n        }, getSegMeta(seg, todayRange))) : createElement(TableBlockEvent, __assign({\n          seg: seg,\n          isDragging: false,\n          isResizing: false,\n          isDateSelecting: false,\n          isSelected: instanceId === selectedInstanceId,\n          defaultDisplayEventEnd: false\n        }, getSegMeta(seg, todayRange))));\n      }));\n    });\n  };\n\n  MorePopover.prototype.positionToHit = function (positionLeft, positionTop, originEl) {\n    var rootEl = this.rootElRef.current;\n\n    if (!originEl || !rootEl) {\n      // why?\n      return null;\n    }\n\n    var originRect = originEl.getBoundingClientRect();\n    var elRect = rootEl.getBoundingClientRect();\n    var newOriginLeft = elRect.left - originRect.left;\n    var newOriginTop = elRect.top - originRect.top;\n    var localLeft = positionLeft - newOriginLeft;\n    var localTop = positionTop - newOriginTop;\n    var date = this.props.date;\n\n    if ( // ugly way to detect intersection\n    localLeft >= 0 && localLeft < elRect.width && localTop >= 0 && localTop < elRect.height) {\n      return {\n        dateSpan: {\n          allDay: true,\n          range: {\n            start: date,\n            end: addDays(date, 1)\n          }\n        },\n        dayEl: rootEl,\n        relativeRect: {\n          left: newOriginLeft,\n          top: newOriginTop,\n          right: elRect.width,\n          bottom: elRect.height\n        },\n        layer: 1\n      };\n    }\n\n    return null;\n  };\n\n  return MorePopover;\n}(DateComponent);\n\nvar Table =\n/** @class */\nfunction (_super) {\n  __extends(Table, _super);\n\n  function Table() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.splitBusinessHourSegs = memoize(splitSegsByRow);\n    _this.splitBgEventSegs = memoize(splitSegsByRow);\n    _this.splitFgEventSegs = memoize(splitSegsByRow);\n    _this.splitDateSelectionSegs = memoize(splitSegsByRow);\n    _this.splitEventDrag = memoize(splitInteractionByRow);\n    _this.splitEventResize = memoize(splitInteractionByRow);\n    _this.buildBuildMoreLinkText = memoize(buildBuildMoreLinkText);\n    _this.morePopoverRef = createRef();\n    _this.rowRefs = new RefMap();\n    _this.state = {\n      morePopoverState: null\n    };\n\n    _this.handleRootEl = function (rootEl) {\n      _this.rootEl = rootEl;\n      setRef(_this.props.elRef, rootEl);\n    }; // TODO: bad names \"more link click\" versus \"more click\"\n\n\n    _this.handleMoreLinkClick = function (arg) {\n      var context = _this.context;\n      var dateEnv = context.dateEnv;\n      var clickOption = context.options.moreLinkClick;\n\n      function segForPublic(seg) {\n        var _a = seg.eventRange,\n            def = _a.def,\n            instance = _a.instance,\n            range = _a.range;\n        return {\n          event: new EventApi(context, def, instance),\n          start: dateEnv.toDate(range.start),\n          end: dateEnv.toDate(range.end),\n          isStart: seg.isStart,\n          isEnd: seg.isEnd\n        };\n      }\n\n      if (typeof clickOption === 'function') {\n        clickOption = clickOption({\n          date: dateEnv.toDate(arg.date),\n          allDay: true,\n          allSegs: arg.allSegs.map(segForPublic),\n          hiddenSegs: arg.hiddenSegs.map(segForPublic),\n          jsEvent: arg.ev,\n          view: context.viewApi\n        }); // hack to handle void\n      }\n\n      if (!clickOption || clickOption === 'popover') {\n        _this.setState({\n          morePopoverState: __assign(__assign({}, arg), {\n            currentFgEventSegs: _this.props.fgEventSegs,\n            fromRow: arg.fromRow,\n            fromCol: arg.fromCol\n          })\n        });\n      } else if (typeof clickOption === 'string') {\n        // a view name\n        context.calendarApi.zoomTo(arg.date, clickOption);\n      }\n    };\n\n    _this.handleMorePopoverClose = function () {\n      _this.setState({\n        morePopoverState: null\n      });\n    };\n\n    return _this;\n  }\n\n  Table.prototype.render = function () {\n    var _this = this;\n\n    var props = this.props;\n    var dateProfile = props.dateProfile,\n        dayMaxEventRows = props.dayMaxEventRows,\n        dayMaxEvents = props.dayMaxEvents,\n        expandRows = props.expandRows;\n    var morePopoverState = this.state.morePopoverState;\n    var rowCnt = props.cells.length;\n    var businessHourSegsByRow = this.splitBusinessHourSegs(props.businessHourSegs, rowCnt);\n    var bgEventSegsByRow = this.splitBgEventSegs(props.bgEventSegs, rowCnt);\n    var fgEventSegsByRow = this.splitFgEventSegs(props.fgEventSegs, rowCnt);\n    var dateSelectionSegsByRow = this.splitDateSelectionSegs(props.dateSelectionSegs, rowCnt);\n    var eventDragByRow = this.splitEventDrag(props.eventDrag, rowCnt);\n    var eventResizeByRow = this.splitEventResize(props.eventResize, rowCnt);\n    var buildMoreLinkText = this.buildBuildMoreLinkText(this.context.options.moreLinkText);\n    var limitViaBalanced = dayMaxEvents === true || dayMaxEventRows === true; // if rows can't expand to fill fixed height, can't do balanced-height event limit\n    // TODO: best place to normalize these options?\n\n    if (limitViaBalanced && !expandRows) {\n      limitViaBalanced = false;\n      dayMaxEventRows = null;\n      dayMaxEvents = null;\n    }\n\n    var classNames = ['fc-daygrid-body', limitViaBalanced ? 'fc-daygrid-body-balanced' : 'fc-daygrid-body-unbalanced', expandRows ? '' : 'fc-daygrid-body-natural'];\n    return createElement(\"div\", {\n      className: classNames.join(' '),\n      ref: this.handleRootEl,\n      style: {\n        // these props are important to give this wrapper correct dimensions for interactions\n        // TODO: if we set it here, can we avoid giving to inner tables?\n        width: props.clientWidth,\n        minWidth: props.tableMinWidth\n      }\n    }, createElement(NowTimer, {\n      unit: \"day\"\n    }, function (nowDate, todayRange) {\n      return createElement(Fragment, null, createElement(\"table\", {\n        className: \"fc-scrollgrid-sync-table\",\n        style: {\n          width: props.clientWidth,\n          minWidth: props.tableMinWidth,\n          height: expandRows ? props.clientHeight : ''\n        }\n      }, props.colGroupNode, createElement(\"tbody\", null, props.cells.map(function (cells, row) {\n        return createElement(TableRow, {\n          ref: _this.rowRefs.createRef(row),\n          key: cells.length ? cells[0].date.toISOString()\n          /* best? or put key on cell? or use diff formatter? */\n          : row // in case there are no cells (like when resource view is loading)\n          ,\n          showDayNumbers: rowCnt > 1,\n          showWeekNumbers: props.showWeekNumbers,\n          todayRange: todayRange,\n          dateProfile: dateProfile,\n          cells: cells,\n          renderIntro: props.renderRowIntro,\n          businessHourSegs: businessHourSegsByRow[row],\n          eventSelection: props.eventSelection,\n          bgEventSegs: bgEventSegsByRow[row].filter(isSegAllDay)\n          /* hack */\n          ,\n          fgEventSegs: fgEventSegsByRow[row],\n          dateSelectionSegs: dateSelectionSegsByRow[row],\n          eventDrag: eventDragByRow[row],\n          eventResize: eventResizeByRow[row],\n          dayMaxEvents: dayMaxEvents,\n          dayMaxEventRows: dayMaxEventRows,\n          clientWidth: props.clientWidth,\n          clientHeight: props.clientHeight,\n          buildMoreLinkText: buildMoreLinkText,\n          onMoreClick: function onMoreClick(arg) {\n            _this.handleMoreLinkClick(__assign(__assign({}, arg), {\n              fromRow: row\n            }));\n          }\n        });\n      }))), !props.forPrint && morePopoverState && morePopoverState.currentFgEventSegs === props.fgEventSegs && createElement(MorePopover, {\n        ref: _this.morePopoverRef,\n        date: morePopoverState.date,\n        dateProfile: dateProfile,\n        segs: morePopoverState.allSegs,\n        alignmentEl: morePopoverState.dayEl,\n        topAlignmentEl: rowCnt === 1 ? props.headerAlignElRef.current : null,\n        onCloseClick: _this.handleMorePopoverClose,\n        selectedInstanceId: props.eventSelection,\n        hiddenInstances: // yuck\n        (props.eventDrag ? props.eventDrag.affectedInstances : null) || (props.eventResize ? props.eventResize.affectedInstances : null) || {},\n        todayRange: todayRange\n      }));\n    }));\n  }; // Hit System\n  // ----------------------------------------------------------------------------------------------------\n\n\n  Table.prototype.prepareHits = function () {\n    this.rowPositions = new PositionCache(this.rootEl, this.rowRefs.collect().map(function (rowObj) {\n      return rowObj.getCellEls()[0];\n    }), // first cell el in each row. TODO: not optimal\n    false, true);\n    this.colPositions = new PositionCache(this.rootEl, this.rowRefs.currentMap[0].getCellEls(), // cell els in first row\n    true, // horizontal\n    false);\n  };\n\n  Table.prototype.positionToHit = function (leftPosition, topPosition) {\n    var morePopover = this.morePopoverRef.current;\n    var morePopoverHit = morePopover ? morePopover.positionToHit(leftPosition, topPosition, this.rootEl) : null;\n    var morePopoverState = this.state.morePopoverState;\n\n    if (morePopoverHit) {\n      return __assign({\n        row: morePopoverState.fromRow,\n        col: morePopoverState.fromCol\n      }, morePopoverHit);\n    }\n\n    var _a = this,\n        colPositions = _a.colPositions,\n        rowPositions = _a.rowPositions;\n\n    var col = colPositions.leftToIndex(leftPosition);\n    var row = rowPositions.topToIndex(topPosition);\n\n    if (row != null && col != null) {\n      return {\n        row: row,\n        col: col,\n        dateSpan: {\n          range: this.getCellRange(row, col),\n          allDay: true\n        },\n        dayEl: this.getCellEl(row, col),\n        relativeRect: {\n          left: colPositions.lefts[col],\n          right: colPositions.rights[col],\n          top: rowPositions.tops[row],\n          bottom: rowPositions.bottoms[row]\n        }\n      };\n    }\n\n    return null;\n  };\n\n  Table.prototype.getCellEl = function (row, col) {\n    return this.rowRefs.currentMap[row].getCellEls()[col]; // TODO: not optimal\n  };\n\n  Table.prototype.getCellRange = function (row, col) {\n    var start = this.props.cells[row][col].date;\n    var end = addDays(start, 1);\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return Table;\n}(DateComponent);\n\nfunction buildBuildMoreLinkText(moreLinkTextInput) {\n  if (typeof moreLinkTextInput === 'function') {\n    return moreLinkTextInput;\n  }\n\n  return function (num) {\n    return \"+\" + num + \" \" + moreLinkTextInput;\n  };\n}\n\nfunction isSegAllDay(seg) {\n  return seg.eventRange.def.allDay;\n}\n\nvar DayTableSlicer =\n/** @class */\nfunction (_super) {\n  __extends(DayTableSlicer, _super);\n\n  function DayTableSlicer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.forceDayIfListItem = true;\n    return _this;\n  }\n\n  DayTableSlicer.prototype.sliceRange = function (dateRange, dayTableModel) {\n    return dayTableModel.sliceRange(dateRange);\n  };\n\n  return DayTableSlicer;\n}(Slicer);\n\nvar DayTable =\n/** @class */\nfunction (_super) {\n  __extends(DayTable, _super);\n\n  function DayTable() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.slicer = new DayTableSlicer();\n    _this.tableRef = createRef();\n\n    _this.handleRootEl = function (rootEl) {\n      if (rootEl) {\n        _this.context.registerInteractiveComponent(_this, {\n          el: rootEl\n        });\n      } else {\n        _this.context.unregisterInteractiveComponent(_this);\n      }\n    };\n\n    return _this;\n  }\n\n  DayTable.prototype.render = function () {\n    var _a = this,\n        props = _a.props,\n        context = _a.context;\n\n    return createElement(Table, __assign({\n      ref: this.tableRef,\n      elRef: this.handleRootEl\n    }, this.slicer.sliceProps(props, props.dateProfile, props.nextDayThreshold, context, props.dayTableModel), {\n      dateProfile: props.dateProfile,\n      cells: props.dayTableModel.cells,\n      colGroupNode: props.colGroupNode,\n      tableMinWidth: props.tableMinWidth,\n      renderRowIntro: props.renderRowIntro,\n      dayMaxEvents: props.dayMaxEvents,\n      dayMaxEventRows: props.dayMaxEventRows,\n      showWeekNumbers: props.showWeekNumbers,\n      expandRows: props.expandRows,\n      headerAlignElRef: props.headerAlignElRef,\n      clientWidth: props.clientWidth,\n      clientHeight: props.clientHeight,\n      forPrint: props.forPrint\n    }));\n  };\n\n  DayTable.prototype.prepareHits = function () {\n    this.tableRef.current.prepareHits();\n  };\n\n  DayTable.prototype.queryHit = function (positionLeft, positionTop) {\n    var rawHit = this.tableRef.current.positionToHit(positionLeft, positionTop);\n\n    if (rawHit) {\n      return {\n        component: this,\n        dateSpan: rawHit.dateSpan,\n        dayEl: rawHit.dayEl,\n        rect: {\n          left: rawHit.relativeRect.left,\n          right: rawHit.relativeRect.right,\n          top: rawHit.relativeRect.top,\n          bottom: rawHit.relativeRect.bottom\n        },\n        layer: 0\n      };\n    }\n\n    return null;\n  };\n\n  return DayTable;\n}(DateComponent);\n\nvar DayTableView =\n/** @class */\nfunction (_super) {\n  __extends(DayTableView, _super);\n\n  function DayTableView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.buildDayTableModel = memoize(buildDayTableModel);\n    _this.headerRef = createRef();\n    _this.tableRef = createRef();\n    return _this;\n  }\n\n  DayTableView.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.context,\n        options = _a.options,\n        dateProfileGenerator = _a.dateProfileGenerator;\n    var props = this.props;\n    var dayTableModel = this.buildDayTableModel(props.dateProfile, dateProfileGenerator);\n    var headerContent = options.dayHeaders && createElement(DayHeader, {\n      ref: this.headerRef,\n      dateProfile: props.dateProfile,\n      dates: dayTableModel.headerDates,\n      datesRepDistinctDays: dayTableModel.rowCnt === 1\n    });\n\n    var bodyContent = function bodyContent(contentArg) {\n      return createElement(DayTable, {\n        ref: _this.tableRef,\n        dateProfile: props.dateProfile,\n        dayTableModel: dayTableModel,\n        businessHours: props.businessHours,\n        dateSelection: props.dateSelection,\n        eventStore: props.eventStore,\n        eventUiBases: props.eventUiBases,\n        eventSelection: props.eventSelection,\n        eventDrag: props.eventDrag,\n        eventResize: props.eventResize,\n        nextDayThreshold: options.nextDayThreshold,\n        colGroupNode: contentArg.tableColGroupNode,\n        tableMinWidth: contentArg.tableMinWidth,\n        dayMaxEvents: options.dayMaxEvents,\n        dayMaxEventRows: options.dayMaxEventRows,\n        showWeekNumbers: options.weekNumbers,\n        expandRows: !props.isHeightAuto,\n        headerAlignElRef: _this.headerElRef,\n        clientWidth: contentArg.clientWidth,\n        clientHeight: contentArg.clientHeight,\n        forPrint: props.forPrint\n      });\n    };\n\n    return options.dayMinWidth ? this.renderHScrollLayout(headerContent, bodyContent, dayTableModel.colCnt, options.dayMinWidth) : this.renderSimpleLayout(headerContent, bodyContent);\n  };\n\n  return DayTableView;\n}(TableView);\n\nfunction buildDayTableModel(dateProfile, dateProfileGenerator) {\n  var daySeries = new DaySeriesModel(dateProfile.renderRange, dateProfileGenerator);\n  return new DayTableModel(daySeries, /year|month|week/.test(dateProfile.currentRangeUnit));\n}\n\nvar TableDateProfileGenerator =\n/** @class */\nfunction (_super) {\n  __extends(TableDateProfileGenerator, _super);\n\n  function TableDateProfileGenerator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  } // Computes the date range that will be rendered.\n\n\n  TableDateProfileGenerator.prototype.buildRenderRange = function (currentRange, currentRangeUnit, isRangeAllDay) {\n    var dateEnv = this.props.dateEnv;\n\n    var renderRange = _super.prototype.buildRenderRange.call(this, currentRange, currentRangeUnit, isRangeAllDay);\n\n    var start = renderRange.start;\n    var end = renderRange.end;\n    var endOfWeek; // year and month views should be aligned with weeks. this is already done for week\n\n    if (/^(year|month)$/.test(currentRangeUnit)) {\n      start = dateEnv.startOfWeek(start); // make end-of-week if not already\n\n      endOfWeek = dateEnv.startOfWeek(end);\n\n      if (endOfWeek.valueOf() !== end.valueOf()) {\n        end = addWeeks(endOfWeek, 1);\n      }\n    } // ensure 6 weeks\n\n\n    if (this.props.monthMode && this.props.fixedWeekCount) {\n      var rowCnt = Math.ceil( // could be partial weeks due to hiddenDays\n      diffWeeks(start, end));\n      end = addWeeks(end, 6 - rowCnt);\n    }\n\n    return {\n      start: start,\n      end: end\n    };\n  };\n\n  return TableDateProfileGenerator;\n}(DateProfileGenerator);\n\nvar OPTION_REFINERS = {\n  moreLinkClick: identity,\n  moreLinkClassNames: identity,\n  moreLinkContent: identity,\n  moreLinkDidMount: identity,\n  moreLinkWillUnmount: identity\n};\nvar main = createPlugin({\n  initialView: 'dayGridMonth',\n  optionRefiners: OPTION_REFINERS,\n  views: {\n    dayGrid: {\n      component: DayTableView,\n      dateProfileGeneratorClass: TableDateProfileGenerator\n    },\n    dayGridDay: {\n      type: 'dayGrid',\n      duration: {\n        days: 1\n      }\n    },\n    dayGridWeek: {\n      type: 'dayGrid',\n      duration: {\n        weeks: 1\n      }\n    },\n    dayGridMonth: {\n      type: 'dayGrid',\n      duration: {\n        months: 1\n      },\n      monthMode: true,\n      fixedWeekCount: true\n    }\n  }\n});\nexport default main;\nexport { DayTableView as DayGridView, DayTable, DayTableSlicer, Table, TableView, buildDayTableModel };","map":null,"metadata":{},"sourceType":"module"}